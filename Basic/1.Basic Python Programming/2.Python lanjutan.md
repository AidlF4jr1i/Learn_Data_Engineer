# MODUL 2: Alur Kontrol dan Struktur Data Python ðŸš€

Selamat datang di modul lanjutan! Setelah berkenalan dengan dasar-dasar Python, kini saatnya kita menyelam lebih dalam untuk memahami bagaimana program membuat keputusan dan mengulang tugas. Kita akan menjelajahi **alur kontrol** (percabangan dan perulangan), cara elegan menangani **kesalahan** (*error handling*), hingga berkenalan dengan struktur data fundamental seperti **Array** dan **Matriks**. Siap untuk naik level? Mari kita mulai!

---

## Konsep Fundamental dalam Python

### Aksi Sekuensial
Pada dasarnya, komputer menjalankan program secara **sekuensial**, artinya instruksi dieksekusi satu per satu, dari baris paling atas hingga paling bawah. Ini adalah alur paling dasar dari setiap program.

```python
# Contoh program sekuensial untuk biodata
print("Selamat datang dalam program Python!\n")
print("Silakan masukkan data diri Anda.")

nama = input("Masukkan nama Anda: ")
tahun_lahir = input("Masukkan tahun lahir Anda: ")
umur = 2024 - int(tahun_lahir) # Menggunakan tahun saat ini untuk perhitungan yang lebih relevan

print(f"\nSelamat datang {nama}! Per {2024}, umur Anda adalah {umur} tahun.")
print("Terima kasih telah menggunakan program Python!")
```

### Interpreter vs. Compiler
Python sering disebut sebagai bahasa yang di-*interpret*. Apa bedanya dengan di-*compile*?

* **Interpreter**: Menerjemahkan dan menjalankan kode **baris per baris** secara langsung. Jika ada kesalahan, program akan berhenti tepat di baris tersebut. Ini memungkinkan kita melihat hasil dengan cepat.
* **Compiler**: Menerjemahkan **seluruh kode** menjadi bahasa mesin terlebih dahulu dalam satu file terpisah (disebut *executable*). File inilah yang kemudian dijalankan.

Sebenarnya, Python menggunakan kombinasi keduanya. Kode Python (`.py`) pertama-tama di-*compile* menjadi format perantara yang disebut *bytecode* (`.pyc`), yang kemudian dieksekusi oleh Python Virtual Machine (PVM) sebagai *interpreter*. Namun, bagi pengguna, prosesnya terasa seperti interpretasi langsung.

### Blok Kode dan Indentasi
**Blok kode** adalah sekumpulan pernyataan yang dijalankan sebagai satu unit, misalnya di dalam sebuah perulangan atau percabangan. Di Python, blok kode tidak menggunakan kurung kurawal `{}` seperti bahasa lain, melainkan menggunakan **indentasi** (biasanya 4 spasi).

```python
# Contoh blok kode dalam perulangan for
# Pernyataan print(i) berada di dalam blok for karena memiliki indentasi
for i in range(5):
    print(i)
```
>âš ï¸ **Penting**: Konsistensi indentasi sangat krusial di Python. Kesalahan indentasi akan menyebabkan `IndentationError`.

### Case-Sensitive
Python bersifat **case-sensitive**, artinya huruf besar dan kecil dianggap berbeda. Variabel `teks` dan `Teks` adalah dua variabel yang sama sekali berbeda.

```python
teks = "Dicoding"
Teks = "Indonesia"

print(teks) # Output: Dicoding
print(Teks) # Output: Indonesia
```

### One-Liner
**One-liner** adalah gaya penulisan kode yang ringkas dalam satu baris. Tujuannya adalah efisiensi, namun pastikan kode tetap mudah dibaca. Tidak semua blok kode bisa dijadikan one-liner.

Contoh klasik adalah menukar nilai dua variabel:

```python
# Cara biasa (membutuhkan variabel sementara)
x = 1
y = 2
temp = x
x = y
y = temp
print(f"Setelah pertukaran (cara biasa): x = {x}, y = {y}")

# Dengan one-liner (lebih Pythonic!)
x = 1
y = 2
x, y = y, x # Proses penukaran terjadi dalam satu baris
print(f"Setelah pertukaran (one-liner): x = {x}, y = {y}")
```

---

## Control Flow: Mengatur Alur Program

**Control flow** adalah urutan eksekusi instruksi dalam program. Dengan control flow, kita bisa membuat program yang dinamis, bukan hanya berjalan lurus dari atas ke bawah.

### Percabangan (`if`, `elif`, `else`)
Percabangan digunakan untuk menjalankan blok kode tertentu jika sebuah kondisi terpenuhi.

1.  **`if`**: Blok kode di dalam `if` hanya akan dieksekusi jika kondisinya bernilai `True`.
    ```python
    score = 100
    if score == 100:
        print("Nilai Anda sempurna!")
    ```
2.  **`elif` (else if)**: Digunakan untuk mengecek kondisi lain jika kondisi `if` sebelumnya `False`. Anda bisa memiliki banyak `elif`.
3.  **`else`**: Blok kode di dalam `else` akan dieksekusi jika semua kondisi `if` dan `elif` di atasnya `False`.

```python
# Contoh lengkap if-elif-else
nilai = 75

if nilai >= 80:
    print("Selamat! Anda mendapat nilai A.")
elif nilai >= 70:
    print("Hore! Anda mendapat nilai B.") # Program akan masuk ke blok ini
elif nilai >= 60:
    print("Hmm.. Anda mendapat nilai C.")
else:
    print("Waduh, Anda mendapat nilai D. Yuk, belajar lebih giat lagi!")
```

> **Catatan**: Python akan mengecek kondisi secara berurutan. Begitu satu kondisi terpenuhi (`True`), blok kodenya akan dieksekusi dan sisa percabangan (`elif` atau `else`) akan dilewati.

### Ternary Operators
Ini adalah cara singkat untuk menulis pernyataan `if-else` dalam satu baris.

**Struktur**: `<nilai_jika_true> if <kondisi> else <nilai_jika_false>`

```python
lulus = True
print("Selamat!") if lulus else print("Perbaiki nilaimu.")
```

---

## Perulangan (`for` dan `while`)

Perulangan digunakan untuk mengeksekusi blok kode berulang kali.

### 1. `for` Loop (Definite Iteration)
Digunakan ketika kita tahu persis berapa kali perulangan akan terjadi. `for` akan mengiterasi setiap elemen dalam sebuah *iterable* (seperti list, tuple, string, atau `range`).

**Format**: `for <variabel> in <iterable>:`

```python
# Iterasi melalui list
var_list = [1, 2, 3]
for i in var_list:
    print(i)

# Menggunakan range()
# range(stop) -> dari 0 sampai sebelum stop
# range(start, stop) -> dari start sampai sebelum stop
# range(start, stop, step) -> dengan lompatan sebesar step
for i in range(1, 10, 2): # Mencetak angka ganjil dari 1 sampai 9
    print(i)
```

### 2. `while` Loop (Indefinite Iteration)
Digunakan ketika perulangan akan terus berjalan **selama** sebuah kondisi bernilai `True`. Kita tidak tahu pasti berapa kali perulangan akan terjadi.

**Format**: `while <kondisi>:`

```python
angka = 1
while angka <= 5:
    print(angka)
    angka += 1 # Penting! Tanpa ini, akan terjadi infinite loop.
```

### 3. Nested Loop (Perulangan Bersarang)
Kita bisa meletakkan satu perulangan di dalam perulangan lain. Perulangan dalam akan menyelesaikan semua iterasinya untuk setiap satu iterasi dari perulangan luar.

```python
# Mencetak pasangan angka
for i in range(1, 3):       # Perulangan luar
    for j in range(1, 3):   # Perulangan dalam
        print(i, j)
```

---

## Kontrol Perulangan

Kita bisa mengontrol jalannya perulangan dengan pernyataan khusus.

1.  **`break`**: Menghentikan perulangan **seketika**. Program akan langsung keluar dari loop.
    ```python
    for huruf in 'Dico ding':
        if huruf == ' ':
            break # Berhenti saat bertemu spasi
        print(f'Huruf saat ini: {huruf}')
    ```
2.  **`continue`**: Menghentikan iterasi **saat ini** dan langsung melompat ke iterasi berikutnya.
    ```python
    for huruf in 'Dico ding':
        if huruf == ' ':
            continue # Melewati spasi dan lanjut ke huruf berikutnya
        print(f'Huruf saat ini: {huruf}')
    ```
3.  **`else` setelah Loop**: Blok `else` akan dieksekusi jika perulangan selesai secara normal (tidak dihentikan oleh `break`).
    ```python
    numbers = [1, 2, 3, 4, 5]
    for num in numbers:
        if num == 6:
            print("Angka ditemukan!")
            break
    else: # Dieksekusi karena loop selesai tanpa menemukan angka 6
        print("Angka tidak ditemukan.")
    ```
4.  **`pass`**: Pernyataan kosong. Digunakan sebagai *placeholder* ketika sintaks memerlukan sebuah blok, tapi kita belum ingin menulis logikanya.
    ```python
    x = 10
    if x > 5:
        pass # Tidak melakukan apa-apa
    else:
        print("Nilai x tidak memenuhi kondisi")
    ```

### List Comprehension
Cara elegan dan ringkas untuk membuat list berdasarkan *iterable* lain.

**Format**: `[<ekspresi> for <item> in <iterable> if <kondisi>]`

```python
# Membuat list pangkat dua dari list angka
angka = [1, 2, 3, 4]
pangkat = [item**2 for item in angka]
print(pangkat) # Output: [1, 4, 9, 16]

# Membuat list angka genap dari 0-10
angka_genap = [i for i in range(11) if i % 2 == 0]
print(angka_genap) # Output: [0, 2, 4, 6, 8, 10]
```

---

## Penanganan Kesalahan (Error & Exception Handling)

Kesalahan dalam program adalah hal yang wajar. Ada dua jenis utama:

1.  **Syntax Errors**: Kesalahan penulisan yang membuat Python tidak mengerti kodemu. Program bahkan tidak akan bisa berjalan.
    ```python
    # Contoh SyntaxError (lupa titik dua)
    # while i < 3
    #     print("Dicoding")
    ```
2.  **Exceptions (Runtime Errors)**: Kesalahan yang terjadi **saat program berjalan**. Sintaksnya benar, tapi ada masalah logika, misalnya membagi dengan nol atau mengakses variabel yang belum dibuat.
    ```python
    # Contoh NameError (variabel 'angka' belum didefinisikan)
    # print(angka)

    # Contoh ZeroDivisionError
    # print(1 / 0)
    ```

### Menangani Exceptions dengan `try-except`
Untuk mencegah program berhenti total saat terjadi *exception*, kita bisa menanganinya dengan blok `try-except`.

**Struktur Lengkap**:
```python
var_dict = {"rata_rata": "1.0"}

try:
    # Kode yang berpotensi menimbulkan error diletakkan di sini
    print(f"rata-rata adalah {var_dict['rata_rata']}")
except KeyError:
    # Blok ini dieksekusi jika terjadi KeyError
    print("Key tidak ditemukan.")
except TypeError:
    # Blok ini dieksekusi jika terjadi TypeError
    print("Anda tidak bisa melakukan operasi pada tipe data yang salah.")
else:
    # Blok ini dieksekusi HANYA JIKA tidak ada error di blok 'try'
    print("Kode ini dieksekusi jika tidak ada exception.")
finally:
    # Blok ini SELALU dieksekusi, baik ada error maupun tidak
    print("Kode ini dieksekusi terlepas dari ada atau tidaknya exception.")
```

### `raise`: Membangkitkan Exception Secara Sengaja
Kita bisa dengan sengaja memunculkan *exception* jika kondisi tertentu tidak terpenuhi.

```python
var = -1
if var < 0:
    raise ValueError("Bilangan negatif tidak diperbolehkan")
else:
    for i in range(var):
        print(i + 1)
```

---

## Struktur Data: Array dan Matriks

### Array di Python
Secara teknis, Python tidak memiliki tipe data *array* bawaan seperti bahasa lain. Namun, **`list`** berfungsi sangat mirip dan sering digunakan sebagai pengganti array.

* **Perbedaan Utama**: `list` bisa berisi elemen dengan tipe data yang berbeda, sedangkan *array* tradisional biasanya hanya berisi satu tipe data.
* **Modul `array`**: Jika benar-benar butuh *array* yang efisien memori dan bertipe data tunggal, Python menyediakan modul `array`.

```python
# Menggunakan list sebagai array
my_array_list = [1, 2, 3, 4, 5]
print(my_array_list)

# Menggunakan modul array (tipe 'i' untuk signed integer)
import array
my_true_array = array.array("i", [1, 2, 3, 4, 5])
print(my_true_array)
```
> Untuk materi ini, kita akan menggunakan **`list`** sebagai representasi array.

### Implementasi Array (List)

* **Deklarasi**:
    ```python
    # Langsung dengan isi
    var_arr = [9, 8, 7, 6, 5]

    # Dengan nilai default menggunakan list comprehension
    var_arr_default = [0 for i in range(5)] # Membuat list [0, 0, 0, 0, 0]
    print(var_arr_default)
    ```
* **Mengakses Elemen**: Menggunakan indeks, yang dimulai dari `0`.
    ```python
    var_arr = [9, 8, 7, 6, 5]
    print(var_arr[0]) # Output: 9
    print(var_arr[2]) # Output: 7
    ```

### Latihan: Mencari Nilai Terbesar dalam Array
Salah satu algoritma sederhana untuk ini adalah membandingkan setiap elemen secara berurutan.

```python
var_arr = [1, 7, 2, 89, 3]
nilai_terbesar = var_arr[0] # Asumsikan elemen pertama adalah yang terbesar

for nilai in var_arr:
    if nilai > nilai_terbesar:
        nilai_terbesar = nilai # Update jika menemukan nilai yang lebih besar

print(f"Nilai terbesar dalam array adalah: {nilai_terbesar}")
```

### Matriks (Array 2 Dimensi)
Matriks adalah kumpulan data yang tersusun dalam baris dan kolom. Di Python, kita bisa mengimplementasikannya menggunakan **nested list** (list di dalam list).

```python
# Matriks 3x3
matriks = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Mengakses elemen (baris 1, kolom 2 -> nilai 6)
# Ingat, indeks dimulai dari 0
print(matriks[1][2])
```

### Matriks dengan NumPy
Untuk operasi matriks yang kompleks dan efisien, menggunakan *library* **NumPy** sangat direkomendasikan. NumPy jauh lebih cepat dan hemat memori dibandingkan *nested list*.

```python
import numpy as np
import sys

# Perbandingan ukuran memori
var_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
var_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8 ,9]])

print("Ukuran list (bytes): ", sys.getsizeof(var_list) * len(var_list))
print("Ukuran NumPy array (bytes): ", var_array.nbytes)
```

**Operasi Matriks dengan NumPy Jauh Lebih Mudah!**

```python
# Mengalikan setiap elemen matriks dengan 2
# Cara biasa dengan nested list
matriks_biasa = [[5, 0], [1, -2]]
hasil_biasa = [[0, 0], [0, 0]]
for i in range(len(matriks_biasa)):
    for j in range(len(matriks_biasa[0])):
        hasil_biasa[i][j] = matriks_biasa[i][j] * 2
print("Hasil (cara biasa):", hasil_biasa)


# Cara mudah dengan NumPy
matriks_numpy = np.array([[5, 0], [1, -2]])
hasil_numpy = matriks_numpy * 2
print("Hasil (NumPy):\n", hasil_numpy)
